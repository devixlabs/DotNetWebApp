Plan:
- Confirm `sample-seed.sql` stays idempotent with category lookups via subqueries and is executed via `SampleDataSeeder`. [DONE]
- Document the Docker workflow for installing `mssql-tools`/`sqlcmd` so future devs can invoke the sample seed file without needing external tooling. [DONE]
- Add focused unit tests for `SampleDataSeeder` so we can run `make test` and catch regressions in the seed step. [DONE]
- Outline manual verification steps for seeding + docker SQL tooling (used by QA/devs to validate the work). [DONE]

VERIFICATION NOTES (2026-01-21):
- ✅ IEntityMetadataService fully implemented and working (Services/EntityMetadataService.cs)
- ✅ DDL → YAML → Models pipeline tested and verified (make test-ddl-pipeline succeeds)
- ✅ Generated models (Product.cs, Category.cs) have correct namespace and EF annotations
- ✅ AppDbContext reflection-based entity discovery works (models in DotNetWebApp.Models.Generated)
- ✅ App runs successfully with `make dev`, dynamic menu shows entities
- ⚠️ QUIRK: ModelGenerator outputs to DotNetWebApp/Models/Generated/ (nested) instead of Models/Generated/
  Fix: Change line 32 in ModelGenerator/Program.cs from "../DotNetWebApp/Models/Generated" to "../Models/Generated"
- NOTE: No unit tests currently exist; consider adding test projects for future tasks

1) Add shared entity metadata resolver [✅ COMPLETE]
- IEntityMetadataService already exists and maps entity name -> AppDictionary entity + CLR type.
- Already used for dynamic entity discovery; no changes needed for this task.

2) Add dynamic API endpoints (non-breaking) [READY TO IMPLEMENT]
- Add a controller for `api/entities/{entityName}` + `api/entities/{entityName}/count` + POST using DbContext.Set(Type).
- Keep Product/Category controllers for now to avoid breaking routes.
- IMPLEMENTATION NOTE: Use EntityMetadataService.Find(entityName) to resolve CLR type, then DbContext.Set(type) for queries.

3) Add generic API client for entities
- Create `IEntityApiService` with `GetEntitiesAsync(entityName)` and `GetCountAsync(entityName)`.
- Use dynamic deserialization to the resolved CLR type.

4) Wire dynamic entity UI path
- Update `Components/Pages/GenericEntityPage.razor` to use `IEntityApiService` and the new `api/entities/` routes.
- Verify DDL -> app.yaml -> models -> API -> UI with `make test-ddl-pipeline`.

5) Replace ProductsSection with EntitySection
- Add `Components/Sections/EntitySection.razor` that renders any entity via metadata + DynamicDataGrid.
- Update `Components/Pages/SpaApp.razor` to render the selected entity (route segment or explicit query string).

6) Generalize dashboard counts
- Replace `DashboardSummary.TotalProducts` with a generic summary that does not assume a primary entity.
- Update `DashboardService` + `Components/Sections/DashboardSection.razor` to use `IEntityApiService`.

7) Make SPA sections data-driven + optional
- Refactor `SpaSection` enum + `SpaSectionService` to build sections from app.yaml entities (keep Dashboard/Settings as optional static).
- Add `EnableSpaExample` flag in `AppCustomizationOptions` + `appsettings.json` (default true).
- Hide the "Application" nav group when disabled; optionally link Home to the entity list.

8) Remove product/category artifacts
- Delete Product/Category controllers, `IProductService`, `ProductService`, and `ProductsSection`.
- Remove product-specific labels from `Models/AppCustomizationOptions.cs` and `appsettings.json`.

9) Docs + summary
- Update `SESSION_SUMMARY.md` and any docs referencing product-specific SPA.
- Document the dynamic API route and SPA example flag.

10) Sample seed data [COMPLETE]
- Confirmed `sample-seed.sql` guards against duplicate inserts and uses subqueries for FKs.
- `SampleDataSeeder` runs the SQL via EF (`ExecuteSqlRawAsync`).
- `make seed` runs `dotnet run -- --seed`, which migrates the schema and invokes the seeder so the sample rows appear automatically.

IMPLEMENTATION SEQUENCE NOTES:
- Tasks 2-4 form a dependency chain: Endpoints → ApiService → GenericEntityPage wiring
- Task 5 (EntitySection) depends on IEntityApiService from task 3
- Task 6 (Dashboard) depends on IEntityApiService from task 3
- Task 7 (Data-driven SPA) builds on tasks 5-6 and GenericEntityPage working
- Task 8 (Remove artifacts) is final cleanup after all replacements work
- Task 9 (Docs) should be done after major changes
- Task 10 (Seed data) is independent and can be done anytime
