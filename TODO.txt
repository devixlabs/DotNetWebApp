
VERIFICATION NOTES (2026-01-21):
- ✅ IEntityMetadataService fully implemented and working (Services/EntityMetadataService.cs)
- ✅ DDL → YAML → Models pipeline tested and verified (make test-ddl-pipeline succeeds)
- ✅ Generated models (Product.cs, Category.cs) have correct namespace and EF annotations
- ✅ AppDbContext reflection-based entity discovery works (models in DotNetWebApp.Models.Generated)
- ✅ App runs successfully with `make dev`, dynamic menu shows entities
- ✅ FIXED (2026-01-21): ModelGenerator now outputs to correct Models/Generated/ location
  - Fixed line 32 in ModelGenerator/Program.cs: "../DotNetWebApp/Models/Generated" → "../Models/Generated"
  - Added ModelGenerator.Tests project with 3 path resolution tests (all passing)
  - Cleaned up incorrect nested DotNetWebApp/DotNetWebApp/Models/Generated directory

1) Add shared entity metadata resolver [✅ COMPLETE]
- IEntityMetadataService already exists and maps entity name -> AppDictionary entity + CLR type.
- Already used for dynamic entity discovery; no changes needed for this task.

2) Add dynamic API endpoints (non-breaking) [✅ COMPLETE]
- Add a controller for `api/entities/{entityName}` + `api/entities/{entityName}/count` + POST using DbContext.Set(Type). [DONE]
- Keep Product/Category controllers for now to avoid breaking routes. [DONE]
- IMPLEMENTATION NOTE: Use EntityMetadataService.Find(entityName) to resolve CLR type, then DbContext.Set(type) for queries. [DONE]
- IMPLEMENTATION DETAILS: Created EntitiesController.cs with reflection-based approach since EF Core 8 lacks non-generic Set(Type) method.
  Uses reflection to call generic Set<T>(), ToListAsync<T>(), and CountAsync<T>() with runtime types.

3) Add generic API client for entities
- Create `IEntityApiService` with `GetEntitiesAsync(entityName)` and `GetCountAsync(entityName)`.
- Use dynamic deserialization to the resolved CLR type.

4) Wire dynamic entity UI path [✅ COMPLETE]
- Update `Components/Pages/GenericEntityPage.razor` to use `IEntityApiService` and the new `api/entities/` routes. [DONE]
- Verify DDL -> app.yaml -> models -> API -> UI with `make test-ddl-pipeline`. [DONE]
- IMPLEMENTATION DETAILS: Created IEntityApiService.cs and EntityApiService.cs for HTTP-based entity operations.
  Updated GenericEntityPage.razor to inject and use IEntityApiService. Added 9 comprehensive unit tests.
  All tests passing (23/23 total), build successful with 0 warnings/errors.

5) Replace ProductsSection with EntitySection
- Add `Components/Sections/EntitySection.razor` that renders any entity via metadata + DynamicDataGrid.
- Update `Components/Pages/SpaApp.razor` to render the selected entity (route segment or explicit query string).

6) Generalize dashboard counts
- Replace `DashboardSummary.TotalProducts` with a generic summary that does not assume a primary entity.
- Update `DashboardService` + `Components/Sections/DashboardSection.razor` to use `IEntityApiService`.

7) Make SPA sections data-driven + optional
- Refactor `SpaSection` enum + `SpaSectionService` to build sections from app.yaml entities (keep Dashboard/Settings as optional static).
- Add `EnableSpaExample` flag in `AppCustomizationOptions` + `appsettings.json` (default true).
- Hide the "Application" nav group when disabled; optionally link Home to the entity list.

8) Remove product/category artifacts
- Delete Product/Category controllers, `IProductService`, `ProductService`, and `ProductsSection`.
- Remove product-specific labels from `Models/AppCustomizationOptions.cs` and `appsettings.json`.

9) Docs + summary
- Update `SESSION_SUMMARY.md` and any docs referencing product-specific SPA.
- Document the dynamic API route and SPA example flag.


IMPLEMENTATION SEQUENCE NOTES:
- Tasks 2-4 form a dependency chain: Endpoints → ApiService → GenericEntityPage wiring
- Task 5 (EntitySection) depends on IEntityApiService from task 3
- Task 6 (Dashboard) depends on IEntityApiService from task 3
- Task 7 (Data-driven SPA) builds on tasks 5-6 and GenericEntityPage working
- Task 8 (Remove artifacts) is final cleanup after all replacements work
- Task 9 (Docs) should be done after major changes
- Task 10 (Seed data) is independent and can be done anytime

=== NEXT ===
a) Look at using dotnet aspnet codegenerator scaffolding for what we have currently or planned for:
   https://learn.microsoft.com/en-us/aspnet/core/fundamentals/tools/dotnet-aspnet-codegenerator?view=aspnetcore-10.0#arguments
b) BUILD OPTIMIZATION TODO (2026-01-22)

Priority #6: Break Project Reference Cycle (Medium Priority - Architectural Refactor)

**Problem:**
ModelGenerator and DdlParser both reference DotNetWebApp.csproj, creating a compile-time
dependency that causes unnecessary rebuilds. When DotNetWebApp changes, both tools rebuild
even though they only need access to model definitions, not the full web application.

**Current Dependency Graph:**
```
DotNetWebApp.csproj (Web API + Blazor Server + Models)
  ↑
  └─── ModelGenerator.csproj (references DotNetWebApp)
  └─── DdlParser.csproj (references DotNetWebApp)
```

**Proposed Solution:**
Extract Models to a separate class library project:

```
DotNetWebApp.Models.csproj (Entities only)
  ↑                           ↑
  │                           │
  │                           └─── ModelGenerator.csproj
  │                           └─── DdlParser.csproj
  │
DotNetWebApp.csproj (Web API + Blazor Server)
```

**Implementation Steps:**
1. Create new project: DotNetWebApp.Models.csproj
2. Move Models/ folder to new project
3. Update DotNetWebApp.csproj to reference Models project
4. Update ModelGenerator.csproj to reference Models project (instead of DotNetWebApp)
5. Update DdlParser.csproj to reference Models project (instead of DotNetWebApp)
6. Update test projects to reference Models project if needed
7. Add Models project to DotNetWebApp.sln
8. Test all build targets (make build, make test, make test-ddl-pipeline)

**Impact:**
- Eliminates unnecessary rebuilds when tools change
- Cleaner separation of concerns
- Better incremental build performance
- Estimated 10-15% additional build speed improvement

**Estimated Effort:** 2-3 hours

**Risk:** Medium - requires thorough testing of all build targets and runtime behavior

**Status:** Documented in BUILD_OPTIMIZATION_SUMMARY.md, not yet implemented

**Note:** All other build optimizations (1-7 plus additional optimizations) are COMPLETE
and documented in BUILD_OPTIMIZATION_SUMMARY.md and BUILD_OPTIMIZATIONS_QUICK_REF.md 

c) <YOUR_NEXT_PLACEHOLDER>

