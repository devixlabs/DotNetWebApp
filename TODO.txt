
VERIFICATION NOTES (2026-01-21):
- ✅ IEntityMetadataService fully implemented and working (Services/EntityMetadataService.cs)
- ✅ DDL → YAML → Models pipeline tested and verified (make test-ddl-pipeline succeeds)
- ✅ Generated models (Product.cs, Category.cs) have correct namespace and EF annotations
- ✅ AppDbContext reflection-based entity discovery works (models in DotNetWebApp.Models.Generated)
- ✅ App runs successfully with `make dev`, dynamic menu shows entities
- ✅ FIXED (2026-01-21): ModelGenerator now outputs to correct Models/Generated/ location
  - Fixed line 32 in ModelGenerator/Program.cs: "../DotNetWebApp/Models/Generated" → "../Models/Generated"
  - Added ModelGenerator.Tests project with 3 path resolution tests (all passing)
  - Cleaned up incorrect nested DotNetWebApp/DotNetWebApp/Models/Generated directory

1) Add shared entity metadata resolver [✅ COMPLETE]
- IEntityMetadataService already exists and maps entity name -> AppDictionary entity + CLR type.
- Already used for dynamic entity discovery; no changes needed for this task.

2) Add dynamic API endpoints (non-breaking) [✅ COMPLETE]
- Add a controller for `api/entities/{entityName}` + `api/entities/{entityName}/count` + POST using DbContext.Set(Type). [DONE]
- Keep Product/Category controllers for now to avoid breaking routes. [DONE]
- IMPLEMENTATION NOTE: Use EntityMetadataService.Find(entityName) to resolve CLR type, then DbContext.Set(type) for queries. [DONE]
- IMPLEMENTATION DETAILS: Created EntitiesController.cs with reflection-based approach since EF Core 8 lacks non-generic Set(Type) method.
  Uses reflection to call generic Set<T>(), ToListAsync<T>(), and CountAsync<T>() with runtime types.

3) Add generic API client for entities
- Create `IEntityApiService` with `GetEntitiesAsync(entityName)` and `GetCountAsync(entityName)`.
- Use dynamic deserialization to the resolved CLR type.

4) Wire dynamic entity UI path
- Update `Components/Pages/GenericEntityPage.razor` to use `IEntityApiService` and the new `api/entities/` routes.
- Verify DDL -> app.yaml -> models -> API -> UI with `make test-ddl-pipeline`.

5) Replace ProductsSection with EntitySection
- Add `Components/Sections/EntitySection.razor` that renders any entity via metadata + DynamicDataGrid.
- Update `Components/Pages/SpaApp.razor` to render the selected entity (route segment or explicit query string).

6) Generalize dashboard counts
- Replace `DashboardSummary.TotalProducts` with a generic summary that does not assume a primary entity.
- Update `DashboardService` + `Components/Sections/DashboardSection.razor` to use `IEntityApiService`.

7) Make SPA sections data-driven + optional
- Refactor `SpaSection` enum + `SpaSectionService` to build sections from app.yaml entities (keep Dashboard/Settings as optional static).
- Add `EnableSpaExample` flag in `AppCustomizationOptions` + `appsettings.json` (default true).
- Hide the "Application" nav group when disabled; optionally link Home to the entity list.

8) Remove product/category artifacts
- Delete Product/Category controllers, `IProductService`, `ProductService`, and `ProductsSection`.
- Remove product-specific labels from `Models/AppCustomizationOptions.cs` and `appsettings.json`.

9) Docs + summary
- Update `SESSION_SUMMARY.md` and any docs referencing product-specific SPA.
- Document the dynamic API route and SPA example flag.


IMPLEMENTATION SEQUENCE NOTES:
- Tasks 2-4 form a dependency chain: Endpoints → ApiService → GenericEntityPage wiring
- Task 5 (EntitySection) depends on IEntityApiService from task 3
- Task 6 (Dashboard) depends on IEntityApiService from task 3
- Task 7 (Data-driven SPA) builds on tasks 5-6 and GenericEntityPage working
- Task 8 (Remove artifacts) is final cleanup after all replacements work
- Task 9 (Docs) should be done after major changes
- Task 10 (Seed data) is independent and can be done anytime
