// <auto-generated>
//     This code was generated by ViewModelGenerator on {{ generated_date }} UTC.
//     SQL Source: {{ view.sql_file }}
//
//     DO NOT EDIT - changes will be overwritten on regeneration.
//     To add custom logic, create a separate {{ view.name }}.cs file with a partial class.
// </auto-generated>

#nullable enable

using System;
using System.ComponentModel.DataAnnotations;

namespace DotNetWebApp.Models.ViewModels
{
    /// <summary>
    /// {{ view.description }}
    /// </summary>
    /// <remarks>
    /// SQL Source: {{ view.sql_file }}
    {{~ if has_parameters ~}}
    /// Parameters:
    {{~ for param in view.parameters ~}}
    ///   - @{{ param.name }} ({{ param.type }}{{ if param.nullable }}?{{ end }}){{ if param.default }} = {{ param.default }}{{ end }}
    {{~ end ~}}
    {{~ end ~}}
    /// </remarks>
    public {{ if view.generate_partial }}partial {{ end }}class {{ view.name }}
    {
        {{~ for property in view.properties ~}}
        {{~ # Determine CLR type from YAML type ~}}
        {{~ if property.type == "datetime" ~}}
        {{~ clr_type = "DateTime" ~}}
        {{~ else if property.type == "datetimeoffset" ~}}
        {{~ clr_type = "DateTimeOffset" ~}}
        {{~ else if property.type == "timespan" ~}}
        {{~ clr_type = "TimeSpan" ~}}
        {{~ else if property.type == "guid" ~}}
        {{~ clr_type = "Guid" ~}}
        {{~ else if property.type == "bytes" ~}}
        {{~ clr_type = "byte[]" ~}}
        {{~ else if property.type == "long" ~}}
        {{~ clr_type = "long" ~}}
        {{~ else if property.type == "short" ~}}
        {{~ clr_type = "short" ~}}
        {{~ else if property.type == "byte" ~}}
        {{~ clr_type = "byte" ~}}
        {{~ else if property.type == "float" ~}}
        {{~ clr_type = "float" ~}}
        {{~ else if property.type == "double" ~}}
        {{~ clr_type = "double" ~}}
        {{~ else ~}}
        {{~ clr_type = property.type ~}}
        {{~ end ~}}
        {{~ # Determine if reference type and nullable suffix ~}}
        {{~ is_reference_type = clr_type == "string" || clr_type == "byte[]" ~}}
        {{~ nullable_suffix = property.nullable ? "?" : "" ~}}
        {{~ # Generate validation attributes ~}}
        {{~ if property.validation ~}}
        {{~ if property.validation.required ~}}
        [Required{{ if property.validation.error_message }}(ErrorMessage = "{{ property.validation.error_message }}"){{ end }}]
        {{~ end ~}}
        {{~ if property.validation.max_length ~}}
        [MaxLength({{ property.validation.max_length }})]
        {{~ end ~}}
        {{~ if property.validation.min_length ~}}
        [MinLength({{ property.validation.min_length }})]
        {{~ end ~}}
        {{~ if property.validation.range && property.validation.range.size >= 2 ~}}
        [Range({{ property.validation.range[0] }}, {{ property.validation.range[1] }})]
        {{~ end ~}}
        {{~ if property.validation.pattern ~}}
        [RegularExpression(@"{{ property.validation.pattern }}"{{ if property.validation.error_message }}, ErrorMessage = "{{ property.validation.error_message }}"{{ end }})]
        {{~ end ~}}
        {{~ else ~}}
        {{~ # Default validation based on nullability ~}}
        {{~ if !property.nullable && clr_type == "string" ~}}
        [Required]
        {{~ end ~}}
        {{~ if property.max_length ~}}
        [MaxLength({{ property.max_length }})]
        {{~ end ~}}
        {{~ end ~}}
        public {{ clr_type }}{{ nullable_suffix }} {{ property.name }} { get; set; }{{ if !property.nullable && clr_type == "string" }} = null!;{{ end }}
        {{~ "\n" ~}}
        {{~ end ~}}
    }
    {{~ if has_parameters ~}}

    /// <summary>
    /// Parameters for {{ view.name }} view query.
    /// </summary>
    public {{ if view.generate_partial }}partial {{ end }}class {{ view.name }}Parameters
    {
        {{~ for param in view.parameters ~}}
        {{~ # Determine CLR type from YAML type ~}}
        {{~ if param.type == "datetime" ~}}
        {{~ clr_type = "DateTime" ~}}
        {{~ else if param.type == "datetimeoffset" ~}}
        {{~ clr_type = "DateTimeOffset" ~}}
        {{~ else if param.type == "timespan" ~}}
        {{~ clr_type = "TimeSpan" ~}}
        {{~ else if param.type == "guid" ~}}
        {{~ clr_type = "Guid" ~}}
        {{~ else if param.type == "bytes" ~}}
        {{~ clr_type = "byte[]" ~}}
        {{~ else if param.type == "long" ~}}
        {{~ clr_type = "long" ~}}
        {{~ else if param.type == "short" ~}}
        {{~ clr_type = "short" ~}}
        {{~ else if param.type == "byte" ~}}
        {{~ clr_type = "byte" ~}}
        {{~ else if param.type == "float" ~}}
        {{~ clr_type = "float" ~}}
        {{~ else if param.type == "double" ~}}
        {{~ clr_type = "double" ~}}
        {{~ else ~}}
        {{~ clr_type = param.type ~}}
        {{~ end ~}}
        {{~ is_reference_type = clr_type == "string" || clr_type == "byte[]" ~}}
        {{~ nullable_suffix = param.nullable ? "?" : "" ~}}
        {{~ # Generate validation attributes for parameters ~}}
        {{~ if param.validation ~}}
        {{~ if param.validation.required ~}}
        [Required{{ if param.validation.error_message }}(ErrorMessage = "{{ param.validation.error_message }}"){{ end }}]
        {{~ end ~}}
        {{~ if param.validation.range && param.validation.range.size >= 2 ~}}
        [Range({{ param.validation.range[0] }}, {{ param.validation.range[1] }})]
        {{~ end ~}}
        {{~ if param.validation.max_length ~}}
        [MaxLength({{ param.validation.max_length }})]
        {{~ end ~}}
        {{~ end ~}}
        public {{ clr_type }}{{ nullable_suffix }} {{ param.name }} { get; set; }{{ if param.default }} = {{ param.default }};{{ end }}
        {{~ "\n" ~}}
        {{~ end ~}}
    }
    {{~ end ~}}
}
